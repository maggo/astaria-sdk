/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from 'ethers'
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from '@ethersproject/abi'
import type { Listener, Provider } from '@ethersproject/providers'
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from './common'

export declare namespace IAstariaRouter {
  export type StrategyDetailsStruct = {
    version: PromiseOrValue<BigNumberish>
    strategist: PromiseOrValue<string>
    deadline: PromiseOrValue<BigNumberish>
    vault: PromiseOrValue<string>
  }

  export type StrategyDetailsStructOutput = [
    number,
    string,
    BigNumber,
    string
  ] & {
    version: number
    strategist: string
    deadline: BigNumber
    vault: string
  }

  export type MerkleDataStruct = {
    root: PromiseOrValue<BytesLike>
    proof: PromiseOrValue<BytesLike>[]
  }

  export type MerkleDataStructOutput = [string, string[]] & {
    root: string
    proof: string[]
  }

  export type NewLienRequestStruct = {
    strategy: IAstariaRouter.StrategyDetailsStruct
    nlrType: PromiseOrValue<BigNumberish>
    nlrDetails: PromiseOrValue<BytesLike>
    merkle: IAstariaRouter.MerkleDataStruct
    amount: PromiseOrValue<BigNumberish>
    v: PromiseOrValue<BigNumberish>
    r: PromiseOrValue<BytesLike>
    s: PromiseOrValue<BytesLike>
  }

  export type NewLienRequestStructOutput = [
    IAstariaRouter.StrategyDetailsStructOutput,
    number,
    string,
    IAstariaRouter.MerkleDataStructOutput,
    BigNumber,
    number,
    string,
    string
  ] & {
    strategy: IAstariaRouter.StrategyDetailsStructOutput
    nlrType: number
    nlrDetails: string
    merkle: IAstariaRouter.MerkleDataStructOutput
    amount: BigNumber
    v: number
    r: string
    s: string
  }

  export type CommitmentStruct = {
    tokenContract: PromiseOrValue<string>
    tokenId: PromiseOrValue<BigNumberish>
    lienRequest: IAstariaRouter.NewLienRequestStruct
  }

  export type CommitmentStructOutput = [
    string,
    BigNumber,
    IAstariaRouter.NewLienRequestStructOutput
  ] & {
    tokenContract: string
    tokenId: BigNumber
    lienRequest: IAstariaRouter.NewLienRequestStructOutput
  }
}

export declare namespace VaultImplementation {
  export type InitParamsStruct = { delegate: PromiseOrValue<string> }

  export type InitParamsStructOutput = [string] & { delegate: string }
}

export interface VaultInterface extends utils.Interface {
  functions: {
    'AUCTION_HOUSE()': FunctionFragment
    'COLLATERAL_TOKEN()': FunctionFragment
    'EPOCH_LENGTH()': FunctionFragment
    'ROUTER()': FunctionFragment
    'START()': FunctionFragment
    'VAULT_FEE()': FunctionFragment
    'VAULT_TYPE()': FunctionFragment
    'buyoutLien(uint256,uint256,(address,uint256,((uint8,address,uint256,address),uint8,bytes,(bytes32,bytes32[]),uint256,uint8,bytes32,bytes32)))': FunctionFragment
    'canLiquidate(uint256,uint256)': FunctionFragment
    'commitToLien((address,uint256,((uint8,address,uint256,address),uint8,bytes,(bytes32,bytes32[]),uint256,uint8,bytes32,bytes32)),address)': FunctionFragment
    'delegate()': FunctionFragment
    'deposit(uint256,address)': FunctionFragment
    'domainSeparator()': FunctionFragment
    'encodeStrategyData((uint8,address,uint256,address),bytes32)': FunctionFragment
    'init((address))': FunctionFragment
    'name()': FunctionFragment
    'onERC721Received(address,address,uint256,bytes)': FunctionFragment
    'owner()': FunctionFragment
    'recipient()': FunctionFragment
    'setDelegate(address)': FunctionFragment
    'symbol()': FunctionFragment
    'underlying()': FunctionFragment
    'withdraw(uint256)': FunctionFragment
  }

  getFunction(
    nameOrSignatureOrTopic:
      | 'AUCTION_HOUSE'
      | 'COLLATERAL_TOKEN'
      | 'EPOCH_LENGTH'
      | 'ROUTER'
      | 'START'
      | 'VAULT_FEE'
      | 'VAULT_TYPE'
      | 'buyoutLien'
      | 'canLiquidate'
      | 'commitToLien'
      | 'delegate'
      | 'deposit'
      | 'domainSeparator'
      | 'encodeStrategyData'
      | 'init'
      | 'name'
      | 'onERC721Received'
      | 'owner'
      | 'recipient'
      | 'setDelegate'
      | 'symbol'
      | 'underlying'
      | 'withdraw'
  ): FunctionFragment

  encodeFunctionData(
    functionFragment: 'AUCTION_HOUSE',
    values?: undefined
  ): string
  encodeFunctionData(
    functionFragment: 'COLLATERAL_TOKEN',
    values?: undefined
  ): string
  encodeFunctionData(
    functionFragment: 'EPOCH_LENGTH',
    values?: undefined
  ): string
  encodeFunctionData(functionFragment: 'ROUTER', values?: undefined): string
  encodeFunctionData(functionFragment: 'START', values?: undefined): string
  encodeFunctionData(functionFragment: 'VAULT_FEE', values?: undefined): string
  encodeFunctionData(functionFragment: 'VAULT_TYPE', values?: undefined): string
  encodeFunctionData(
    functionFragment: 'buyoutLien',
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>,
      IAstariaRouter.CommitmentStruct
    ]
  ): string
  encodeFunctionData(
    functionFragment: 'canLiquidate',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<BigNumberish>]
  ): string
  encodeFunctionData(
    functionFragment: 'commitToLien',
    values: [IAstariaRouter.CommitmentStruct, PromiseOrValue<string>]
  ): string
  encodeFunctionData(functionFragment: 'delegate', values?: undefined): string
  encodeFunctionData(
    functionFragment: 'deposit',
    values: [PromiseOrValue<BigNumberish>, PromiseOrValue<string>]
  ): string
  encodeFunctionData(
    functionFragment: 'domainSeparator',
    values?: undefined
  ): string
  encodeFunctionData(
    functionFragment: 'encodeStrategyData',
    values: [IAstariaRouter.StrategyDetailsStruct, PromiseOrValue<BytesLike>]
  ): string
  encodeFunctionData(
    functionFragment: 'init',
    values: [VaultImplementation.InitParamsStruct]
  ): string
  encodeFunctionData(functionFragment: 'name', values?: undefined): string
  encodeFunctionData(
    functionFragment: 'onERC721Received',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>
    ]
  ): string
  encodeFunctionData(functionFragment: 'owner', values?: undefined): string
  encodeFunctionData(functionFragment: 'recipient', values?: undefined): string
  encodeFunctionData(
    functionFragment: 'setDelegate',
    values: [PromiseOrValue<string>]
  ): string
  encodeFunctionData(functionFragment: 'symbol', values?: undefined): string
  encodeFunctionData(functionFragment: 'underlying', values?: undefined): string
  encodeFunctionData(
    functionFragment: 'withdraw',
    values: [PromiseOrValue<BigNumberish>]
  ): string

  decodeFunctionResult(
    functionFragment: 'AUCTION_HOUSE',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: 'COLLATERAL_TOKEN',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: 'EPOCH_LENGTH',
    data: BytesLike
  ): Result
  decodeFunctionResult(functionFragment: 'ROUTER', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'START', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'VAULT_FEE', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'VAULT_TYPE', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'buyoutLien', data: BytesLike): Result
  decodeFunctionResult(
    functionFragment: 'canLiquidate',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: 'commitToLien',
    data: BytesLike
  ): Result
  decodeFunctionResult(functionFragment: 'delegate', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'deposit', data: BytesLike): Result
  decodeFunctionResult(
    functionFragment: 'domainSeparator',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: 'encodeStrategyData',
    data: BytesLike
  ): Result
  decodeFunctionResult(functionFragment: 'init', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'name', data: BytesLike): Result
  decodeFunctionResult(
    functionFragment: 'onERC721Received',
    data: BytesLike
  ): Result
  decodeFunctionResult(functionFragment: 'owner', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'recipient', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'setDelegate', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'symbol', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'underlying', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'withdraw', data: BytesLike): Result

  events: {
    'NewLien(bytes32,address,uint256,uint256)': EventFragment
    'NewVault(address,address)': EventFragment
  }

  getEvent(nameOrSignatureOrTopic: 'NewLien'): EventFragment
  getEvent(nameOrSignatureOrTopic: 'NewVault'): EventFragment
}

export interface NewLienEventObject {
  strategyRoot: string
  tokenContract: string
  tokenId: BigNumber
  amount: BigNumber
}
export type NewLienEvent = TypedEvent<
  [string, string, BigNumber, BigNumber],
  NewLienEventObject
>

export type NewLienEventFilter = TypedEventFilter<NewLienEvent>

export interface NewVaultEventObject {
  appraiser: string
  vault: string
}
export type NewVaultEvent = TypedEvent<[string, string], NewVaultEventObject>

export type NewVaultEventFilter = TypedEventFilter<NewVaultEvent>

export interface Vault extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this
  attach(addressOrName: string): this
  deployed(): Promise<this>

  interface: VaultInterface

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>
  listeners(eventName?: string): Array<Listener>
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this
  removeAllListeners(eventName?: string): this
  off: OnEvent<this>
  on: OnEvent<this>
  once: OnEvent<this>
  removeListener: OnEvent<this>

  functions: {
    AUCTION_HOUSE(overrides?: CallOverrides): Promise<[string]>

    COLLATERAL_TOKEN(overrides?: CallOverrides): Promise<[string]>

    EPOCH_LENGTH(overrides?: CallOverrides): Promise<[BigNumber]>

    ROUTER(overrides?: CallOverrides): Promise<[string]>

    START(overrides?: CallOverrides): Promise<[BigNumber]>

    VAULT_FEE(overrides?: CallOverrides): Promise<[BigNumber]>

    VAULT_TYPE(overrides?: CallOverrides): Promise<[number]>

    buyoutLien(
      collateralId: PromiseOrValue<BigNumberish>,
      position: PromiseOrValue<BigNumberish>,
      incomingTerms: IAstariaRouter.CommitmentStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>

    canLiquidate(
      collateralId: PromiseOrValue<BigNumberish>,
      position: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[boolean]>

    commitToLien(
      params: IAstariaRouter.CommitmentStruct,
      receiver: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>

    delegate(overrides?: CallOverrides): Promise<[string]>

    deposit(
      amount: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>

    domainSeparator(overrides?: CallOverrides): Promise<[string]>

    encodeStrategyData(
      strategy: IAstariaRouter.StrategyDetailsStruct,
      root: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[string]>

    init(
      params: VaultImplementation.InitParamsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>

    name(overrides?: CallOverrides): Promise<[string]>

    onERC721Received(
      operator_: PromiseOrValue<string>,
      from_: PromiseOrValue<string>,
      tokenId_: PromiseOrValue<BigNumberish>,
      data_: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[string]>

    owner(overrides?: CallOverrides): Promise<[string]>

    recipient(overrides?: CallOverrides): Promise<[string]>

    setDelegate(
      delegate_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>

    symbol(overrides?: CallOverrides): Promise<[string]>

    underlying(overrides?: CallOverrides): Promise<[string]>

    withdraw(
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>
  }

  AUCTION_HOUSE(overrides?: CallOverrides): Promise<string>

  COLLATERAL_TOKEN(overrides?: CallOverrides): Promise<string>

  EPOCH_LENGTH(overrides?: CallOverrides): Promise<BigNumber>

  ROUTER(overrides?: CallOverrides): Promise<string>

  START(overrides?: CallOverrides): Promise<BigNumber>

  VAULT_FEE(overrides?: CallOverrides): Promise<BigNumber>

  VAULT_TYPE(overrides?: CallOverrides): Promise<number>

  buyoutLien(
    collateralId: PromiseOrValue<BigNumberish>,
    position: PromiseOrValue<BigNumberish>,
    incomingTerms: IAstariaRouter.CommitmentStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>

  canLiquidate(
    collateralId: PromiseOrValue<BigNumberish>,
    position: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<boolean>

  commitToLien(
    params: IAstariaRouter.CommitmentStruct,
    receiver: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>

  delegate(overrides?: CallOverrides): Promise<string>

  deposit(
    amount: PromiseOrValue<BigNumberish>,
    arg1: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>

  domainSeparator(overrides?: CallOverrides): Promise<string>

  encodeStrategyData(
    strategy: IAstariaRouter.StrategyDetailsStruct,
    root: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<string>

  init(
    params: VaultImplementation.InitParamsStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>

  name(overrides?: CallOverrides): Promise<string>

  onERC721Received(
    operator_: PromiseOrValue<string>,
    from_: PromiseOrValue<string>,
    tokenId_: PromiseOrValue<BigNumberish>,
    data_: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<string>

  owner(overrides?: CallOverrides): Promise<string>

  recipient(overrides?: CallOverrides): Promise<string>

  setDelegate(
    delegate_: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>

  symbol(overrides?: CallOverrides): Promise<string>

  underlying(overrides?: CallOverrides): Promise<string>

  withdraw(
    amount: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>

  callStatic: {
    AUCTION_HOUSE(overrides?: CallOverrides): Promise<string>

    COLLATERAL_TOKEN(overrides?: CallOverrides): Promise<string>

    EPOCH_LENGTH(overrides?: CallOverrides): Promise<BigNumber>

    ROUTER(overrides?: CallOverrides): Promise<string>

    START(overrides?: CallOverrides): Promise<BigNumber>

    VAULT_FEE(overrides?: CallOverrides): Promise<BigNumber>

    VAULT_TYPE(overrides?: CallOverrides): Promise<number>

    buyoutLien(
      collateralId: PromiseOrValue<BigNumberish>,
      position: PromiseOrValue<BigNumberish>,
      incomingTerms: IAstariaRouter.CommitmentStruct,
      overrides?: CallOverrides
    ): Promise<void>

    canLiquidate(
      collateralId: PromiseOrValue<BigNumberish>,
      position: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<boolean>

    commitToLien(
      params: IAstariaRouter.CommitmentStruct,
      receiver: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>

    delegate(overrides?: CallOverrides): Promise<string>

    deposit(
      amount: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>

    domainSeparator(overrides?: CallOverrides): Promise<string>

    encodeStrategyData(
      strategy: IAstariaRouter.StrategyDetailsStruct,
      root: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<string>

    init(
      params: VaultImplementation.InitParamsStruct,
      overrides?: CallOverrides
    ): Promise<void>

    name(overrides?: CallOverrides): Promise<string>

    onERC721Received(
      operator_: PromiseOrValue<string>,
      from_: PromiseOrValue<string>,
      tokenId_: PromiseOrValue<BigNumberish>,
      data_: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<string>

    owner(overrides?: CallOverrides): Promise<string>

    recipient(overrides?: CallOverrides): Promise<string>

    setDelegate(
      delegate_: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>

    symbol(overrides?: CallOverrides): Promise<string>

    underlying(overrides?: CallOverrides): Promise<string>

    withdraw(
      amount: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>
  }

  filters: {
    'NewLien(bytes32,address,uint256,uint256)'(
      strategyRoot?: null,
      tokenContract?: null,
      tokenId?: null,
      amount?: null
    ): NewLienEventFilter
    NewLien(
      strategyRoot?: null,
      tokenContract?: null,
      tokenId?: null,
      amount?: null
    ): NewLienEventFilter

    'NewVault(address,address)'(
      appraiser?: null,
      vault?: null
    ): NewVaultEventFilter
    NewVault(appraiser?: null, vault?: null): NewVaultEventFilter
  }

  estimateGas: {
    AUCTION_HOUSE(overrides?: CallOverrides): Promise<BigNumber>

    COLLATERAL_TOKEN(overrides?: CallOverrides): Promise<BigNumber>

    EPOCH_LENGTH(overrides?: CallOverrides): Promise<BigNumber>

    ROUTER(overrides?: CallOverrides): Promise<BigNumber>

    START(overrides?: CallOverrides): Promise<BigNumber>

    VAULT_FEE(overrides?: CallOverrides): Promise<BigNumber>

    VAULT_TYPE(overrides?: CallOverrides): Promise<BigNumber>

    buyoutLien(
      collateralId: PromiseOrValue<BigNumberish>,
      position: PromiseOrValue<BigNumberish>,
      incomingTerms: IAstariaRouter.CommitmentStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>

    canLiquidate(
      collateralId: PromiseOrValue<BigNumberish>,
      position: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>

    commitToLien(
      params: IAstariaRouter.CommitmentStruct,
      receiver: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>

    delegate(overrides?: CallOverrides): Promise<BigNumber>

    deposit(
      amount: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>

    domainSeparator(overrides?: CallOverrides): Promise<BigNumber>

    encodeStrategyData(
      strategy: IAstariaRouter.StrategyDetailsStruct,
      root: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>

    init(
      params: VaultImplementation.InitParamsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>

    name(overrides?: CallOverrides): Promise<BigNumber>

    onERC721Received(
      operator_: PromiseOrValue<string>,
      from_: PromiseOrValue<string>,
      tokenId_: PromiseOrValue<BigNumberish>,
      data_: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>

    owner(overrides?: CallOverrides): Promise<BigNumber>

    recipient(overrides?: CallOverrides): Promise<BigNumber>

    setDelegate(
      delegate_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>

    symbol(overrides?: CallOverrides): Promise<BigNumber>

    underlying(overrides?: CallOverrides): Promise<BigNumber>

    withdraw(
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>
  }

  populateTransaction: {
    AUCTION_HOUSE(overrides?: CallOverrides): Promise<PopulatedTransaction>

    COLLATERAL_TOKEN(overrides?: CallOverrides): Promise<PopulatedTransaction>

    EPOCH_LENGTH(overrides?: CallOverrides): Promise<PopulatedTransaction>

    ROUTER(overrides?: CallOverrides): Promise<PopulatedTransaction>

    START(overrides?: CallOverrides): Promise<PopulatedTransaction>

    VAULT_FEE(overrides?: CallOverrides): Promise<PopulatedTransaction>

    VAULT_TYPE(overrides?: CallOverrides): Promise<PopulatedTransaction>

    buyoutLien(
      collateralId: PromiseOrValue<BigNumberish>,
      position: PromiseOrValue<BigNumberish>,
      incomingTerms: IAstariaRouter.CommitmentStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>

    canLiquidate(
      collateralId: PromiseOrValue<BigNumberish>,
      position: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>

    commitToLien(
      params: IAstariaRouter.CommitmentStruct,
      receiver: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>

    delegate(overrides?: CallOverrides): Promise<PopulatedTransaction>

    deposit(
      amount: PromiseOrValue<BigNumberish>,
      arg1: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>

    domainSeparator(overrides?: CallOverrides): Promise<PopulatedTransaction>

    encodeStrategyData(
      strategy: IAstariaRouter.StrategyDetailsStruct,
      root: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>

    init(
      params: VaultImplementation.InitParamsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>

    name(overrides?: CallOverrides): Promise<PopulatedTransaction>

    onERC721Received(
      operator_: PromiseOrValue<string>,
      from_: PromiseOrValue<string>,
      tokenId_: PromiseOrValue<BigNumberish>,
      data_: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>

    recipient(overrides?: CallOverrides): Promise<PopulatedTransaction>

    setDelegate(
      delegate_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>

    symbol(overrides?: CallOverrides): Promise<PopulatedTransaction>

    underlying(overrides?: CallOverrides): Promise<PopulatedTransaction>

    withdraw(
      amount: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>
  }
}
