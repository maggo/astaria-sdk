/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PopulatedTransaction,
  Signer,
  utils,
} from 'ethers'
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from '@ethersproject/abi'
import type { Listener, Provider } from '@ethersproject/providers'
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from './common'

export declare namespace ILienToken {
  export type DetailsStruct = {
    maxAmount: PromiseOrValue<BigNumberish>
    rate: PromiseOrValue<BigNumberish>
    duration: PromiseOrValue<BigNumberish>
    maxPotentialDebt: PromiseOrValue<BigNumberish>
    liquidationInitialAsk: PromiseOrValue<BigNumberish>
  }

  export type DetailsStructOutput = [
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    maxAmount: BigNumber
    rate: BigNumber
    duration: BigNumber
    maxPotentialDebt: BigNumber
    liquidationInitialAsk: BigNumber
  }

  export type LienStruct = {
    collateralType: PromiseOrValue<BigNumberish>
    token: PromiseOrValue<string>
    vault: PromiseOrValue<string>
    strategyRoot: PromiseOrValue<BytesLike>
    collateralId: PromiseOrValue<BigNumberish>
    details: ILienToken.DetailsStruct
  }

  export type LienStructOutput = [
    number,
    string,
    string,
    string,
    BigNumber,
    ILienToken.DetailsStructOutput
  ] & {
    collateralType: number
    token: string
    vault: string
    strategyRoot: string
    collateralId: BigNumber
    details: ILienToken.DetailsStructOutput
  }

  export type PointStruct = {
    amount: PromiseOrValue<BigNumberish>
    last: PromiseOrValue<BigNumberish>
    end: PromiseOrValue<BigNumberish>
    lienId: PromiseOrValue<BigNumberish>
  }

  export type PointStructOutput = [BigNumber, number, number, BigNumber] & {
    amount: BigNumber
    last: number
    end: number
    lienId: BigNumber
  }

  export type StackStruct = {
    lien: ILienToken.LienStruct
    point: ILienToken.PointStruct
  }

  export type StackStructOutput = [
    ILienToken.LienStructOutput,
    ILienToken.PointStructOutput
  ] & {
    lien: ILienToken.LienStructOutput
    point: ILienToken.PointStructOutput
  }
}

export declare namespace IAstariaRouter {
  export type StrategyDetailsParamStruct = {
    version: PromiseOrValue<BigNumberish>
    deadline: PromiseOrValue<BigNumberish>
    vault: PromiseOrValue<string>
  }

  export type StrategyDetailsParamStructOutput = [number, BigNumber, string] & {
    version: number
    deadline: BigNumber
    vault: string
  }

  export type MerkleDataStruct = {
    root: PromiseOrValue<BytesLike>
    proof: PromiseOrValue<BytesLike>[]
  }

  export type MerkleDataStructOutput = [string, string[]] & {
    root: string
    proof: string[]
  }

  export type NewLienRequestStruct = {
    strategy: IAstariaRouter.StrategyDetailsParamStruct
    stack: ILienToken.StackStruct[]
    nlrDetails: PromiseOrValue<BytesLike>
    merkle: IAstariaRouter.MerkleDataStruct
    amount: PromiseOrValue<BigNumberish>
    v: PromiseOrValue<BigNumberish>
    r: PromiseOrValue<BytesLike>
    s: PromiseOrValue<BytesLike>
  }

  export type NewLienRequestStructOutput = [
    IAstariaRouter.StrategyDetailsParamStructOutput,
    ILienToken.StackStructOutput[],
    string,
    IAstariaRouter.MerkleDataStructOutput,
    BigNumber,
    number,
    string,
    string
  ] & {
    strategy: IAstariaRouter.StrategyDetailsParamStructOutput
    stack: ILienToken.StackStructOutput[]
    nlrDetails: string
    merkle: IAstariaRouter.MerkleDataStructOutput
    amount: BigNumber
    v: number
    r: string
    s: string
  }

  export type CommitmentStruct = {
    tokenContract: PromiseOrValue<string>
    tokenId: PromiseOrValue<BigNumberish>
    lienRequest: IAstariaRouter.NewLienRequestStruct
  }

  export type CommitmentStructOutput = [
    string,
    BigNumber,
    IAstariaRouter.NewLienRequestStructOutput
  ] & {
    tokenContract: string
    tokenId: BigNumber
    lienRequest: IAstariaRouter.NewLienRequestStructOutput
  }
}

export declare namespace IVaultImplementation {
  export type InitParamsStruct = {
    delegate: PromiseOrValue<string>
    allowListEnabled: PromiseOrValue<boolean>
    allowList: PromiseOrValue<string>[]
    depositCap: PromiseOrValue<BigNumberish>
  }

  export type InitParamsStructOutput = [
    string,
    boolean,
    string[],
    BigNumber
  ] & {
    delegate: string
    allowListEnabled: boolean
    allowList: string[]
    depositCap: BigNumber
  }
}

export interface VaultImplementationInterface extends utils.Interface {
  functions: {
    'COLLATERAL_TOKEN()': FunctionFragment
    'EPOCH_LENGTH()': FunctionFragment
    'IMPL_TYPE()': FunctionFragment
    'ROUTER()': FunctionFragment
    'START()': FunctionFragment
    'STRATEGY_TYPEHASH()': FunctionFragment
    'VAULT_FEE()': FunctionFragment
    'asset()': FunctionFragment
    'buyoutLien(((uint8,address,address,bytes32,uint256,(uint256,uint256,uint256,uint256,uint256)),(uint256,uint40,uint40,uint256))[],uint8,(address,uint256,((uint8,uint256,address),((uint8,address,address,bytes32,uint256,(uint256,uint256,uint256,uint256,uint256)),(uint256,uint40,uint40,uint256))[],bytes,(bytes32,bytes32[]),uint256,uint8,bytes32,bytes32)))': FunctionFragment
    'commitToLien((address,uint256,((uint8,uint256,address),((uint8,address,address,bytes32,uint256,(uint256,uint256,uint256,uint256,uint256)),(uint256,uint40,uint40,uint256))[],bytes,(bytes32,bytes32[]),uint256,uint8,bytes32,bytes32)))': FunctionFragment
    'disableAllowList()': FunctionFragment
    'domainSeparator()': FunctionFragment
    'enableAllowList()': FunctionFragment
    'encodeStrategyData((uint8,uint256,address),bytes32)': FunctionFragment
    'getShutdown()': FunctionFragment
    'getStrategistNonce()': FunctionFragment
    'incrementNonce()': FunctionFragment
    'init((address,bool,address[],uint256))': FunctionFragment
    'isDelegateOrOwner(address)': FunctionFragment
    'modifyAllowList(address,bool)': FunctionFragment
    'modifyDepositCap(uint256)': FunctionFragment
    'name()': FunctionFragment
    'onERC721Received(address,address,uint256,bytes)': FunctionFragment
    'owner()': FunctionFragment
    'recipient()': FunctionFragment
    'setDelegate(address)': FunctionFragment
    'shutdown()': FunctionFragment
    'supportsInterface(bytes4)': FunctionFragment
    'symbol()': FunctionFragment
  }

  getFunction(
    nameOrSignatureOrTopic:
      | 'COLLATERAL_TOKEN'
      | 'EPOCH_LENGTH'
      | 'IMPL_TYPE'
      | 'ROUTER'
      | 'START'
      | 'STRATEGY_TYPEHASH'
      | 'VAULT_FEE'
      | 'asset'
      | 'buyoutLien'
      | 'commitToLien'
      | 'disableAllowList'
      | 'domainSeparator'
      | 'enableAllowList'
      | 'encodeStrategyData'
      | 'getShutdown'
      | 'getStrategistNonce'
      | 'incrementNonce'
      | 'init'
      | 'isDelegateOrOwner'
      | 'modifyAllowList'
      | 'modifyDepositCap'
      | 'name'
      | 'onERC721Received'
      | 'owner'
      | 'recipient'
      | 'setDelegate'
      | 'shutdown'
      | 'supportsInterface'
      | 'symbol'
  ): FunctionFragment

  encodeFunctionData(
    functionFragment: 'COLLATERAL_TOKEN',
    values?: undefined
  ): string
  encodeFunctionData(
    functionFragment: 'EPOCH_LENGTH',
    values?: undefined
  ): string
  encodeFunctionData(functionFragment: 'IMPL_TYPE', values?: undefined): string
  encodeFunctionData(functionFragment: 'ROUTER', values?: undefined): string
  encodeFunctionData(functionFragment: 'START', values?: undefined): string
  encodeFunctionData(
    functionFragment: 'STRATEGY_TYPEHASH',
    values?: undefined
  ): string
  encodeFunctionData(functionFragment: 'VAULT_FEE', values?: undefined): string
  encodeFunctionData(functionFragment: 'asset', values?: undefined): string
  encodeFunctionData(
    functionFragment: 'buyoutLien',
    values: [
      ILienToken.StackStruct[],
      PromiseOrValue<BigNumberish>,
      IAstariaRouter.CommitmentStruct
    ]
  ): string
  encodeFunctionData(
    functionFragment: 'commitToLien',
    values: [IAstariaRouter.CommitmentStruct]
  ): string
  encodeFunctionData(
    functionFragment: 'disableAllowList',
    values?: undefined
  ): string
  encodeFunctionData(
    functionFragment: 'domainSeparator',
    values?: undefined
  ): string
  encodeFunctionData(
    functionFragment: 'enableAllowList',
    values?: undefined
  ): string
  encodeFunctionData(
    functionFragment: 'encodeStrategyData',
    values: [
      IAstariaRouter.StrategyDetailsParamStruct,
      PromiseOrValue<BytesLike>
    ]
  ): string
  encodeFunctionData(
    functionFragment: 'getShutdown',
    values?: undefined
  ): string
  encodeFunctionData(
    functionFragment: 'getStrategistNonce',
    values?: undefined
  ): string
  encodeFunctionData(
    functionFragment: 'incrementNonce',
    values?: undefined
  ): string
  encodeFunctionData(
    functionFragment: 'init',
    values: [IVaultImplementation.InitParamsStruct]
  ): string
  encodeFunctionData(
    functionFragment: 'isDelegateOrOwner',
    values: [PromiseOrValue<string>]
  ): string
  encodeFunctionData(
    functionFragment: 'modifyAllowList',
    values: [PromiseOrValue<string>, PromiseOrValue<boolean>]
  ): string
  encodeFunctionData(
    functionFragment: 'modifyDepositCap',
    values: [PromiseOrValue<BigNumberish>]
  ): string
  encodeFunctionData(functionFragment: 'name', values?: undefined): string
  encodeFunctionData(
    functionFragment: 'onERC721Received',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BytesLike>
    ]
  ): string
  encodeFunctionData(functionFragment: 'owner', values?: undefined): string
  encodeFunctionData(functionFragment: 'recipient', values?: undefined): string
  encodeFunctionData(
    functionFragment: 'setDelegate',
    values: [PromiseOrValue<string>]
  ): string
  encodeFunctionData(functionFragment: 'shutdown', values?: undefined): string
  encodeFunctionData(
    functionFragment: 'supportsInterface',
    values: [PromiseOrValue<BytesLike>]
  ): string
  encodeFunctionData(functionFragment: 'symbol', values?: undefined): string

  decodeFunctionResult(
    functionFragment: 'COLLATERAL_TOKEN',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: 'EPOCH_LENGTH',
    data: BytesLike
  ): Result
  decodeFunctionResult(functionFragment: 'IMPL_TYPE', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'ROUTER', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'START', data: BytesLike): Result
  decodeFunctionResult(
    functionFragment: 'STRATEGY_TYPEHASH',
    data: BytesLike
  ): Result
  decodeFunctionResult(functionFragment: 'VAULT_FEE', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'asset', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'buyoutLien', data: BytesLike): Result
  decodeFunctionResult(
    functionFragment: 'commitToLien',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: 'disableAllowList',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: 'domainSeparator',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: 'enableAllowList',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: 'encodeStrategyData',
    data: BytesLike
  ): Result
  decodeFunctionResult(functionFragment: 'getShutdown', data: BytesLike): Result
  decodeFunctionResult(
    functionFragment: 'getStrategistNonce',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: 'incrementNonce',
    data: BytesLike
  ): Result
  decodeFunctionResult(functionFragment: 'init', data: BytesLike): Result
  decodeFunctionResult(
    functionFragment: 'isDelegateOrOwner',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: 'modifyAllowList',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: 'modifyDepositCap',
    data: BytesLike
  ): Result
  decodeFunctionResult(functionFragment: 'name', data: BytesLike): Result
  decodeFunctionResult(
    functionFragment: 'onERC721Received',
    data: BytesLike
  ): Result
  decodeFunctionResult(functionFragment: 'owner', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'recipient', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'setDelegate', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'shutdown', data: BytesLike): Result
  decodeFunctionResult(
    functionFragment: 'supportsInterface',
    data: BytesLike
  ): Result
  decodeFunctionResult(functionFragment: 'symbol', data: BytesLike): Result

  events: {
    'AllowListEnabled(bool)': EventFragment
    'AllowListUpdated(address,bool)': EventFragment
    'DelegateUpdated(address)': EventFragment
    'IncrementNonce(uint256)': EventFragment
    'NonceUpdated(uint256)': EventFragment
    'VaultShutdown()': EventFragment
  }

  getEvent(nameOrSignatureOrTopic: 'AllowListEnabled'): EventFragment
  getEvent(nameOrSignatureOrTopic: 'AllowListUpdated'): EventFragment
  getEvent(nameOrSignatureOrTopic: 'DelegateUpdated'): EventFragment
  getEvent(nameOrSignatureOrTopic: 'IncrementNonce'): EventFragment
  getEvent(nameOrSignatureOrTopic: 'NonceUpdated'): EventFragment
  getEvent(nameOrSignatureOrTopic: 'VaultShutdown'): EventFragment
}

export interface AllowListEnabledEventObject {
  arg0: boolean
}
export type AllowListEnabledEvent = TypedEvent<
  [boolean],
  AllowListEnabledEventObject
>

export type AllowListEnabledEventFilter =
  TypedEventFilter<AllowListEnabledEvent>

export interface AllowListUpdatedEventObject {
  arg0: string
  arg1: boolean
}
export type AllowListUpdatedEvent = TypedEvent<
  [string, boolean],
  AllowListUpdatedEventObject
>

export type AllowListUpdatedEventFilter =
  TypedEventFilter<AllowListUpdatedEvent>

export interface DelegateUpdatedEventObject {
  arg0: string
}
export type DelegateUpdatedEvent = TypedEvent<
  [string],
  DelegateUpdatedEventObject
>

export type DelegateUpdatedEventFilter = TypedEventFilter<DelegateUpdatedEvent>

export interface IncrementNonceEventObject {
  nonce: BigNumber
}
export type IncrementNonceEvent = TypedEvent<
  [BigNumber],
  IncrementNonceEventObject
>

export type IncrementNonceEventFilter = TypedEventFilter<IncrementNonceEvent>

export interface NonceUpdatedEventObject {
  nonce: BigNumber
}
export type NonceUpdatedEvent = TypedEvent<[BigNumber], NonceUpdatedEventObject>

export type NonceUpdatedEventFilter = TypedEventFilter<NonceUpdatedEvent>

export interface VaultShutdownEventObject {}
export type VaultShutdownEvent = TypedEvent<[], VaultShutdownEventObject>

export type VaultShutdownEventFilter = TypedEventFilter<VaultShutdownEvent>

export interface VaultImplementation extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this
  attach(addressOrName: string): this
  deployed(): Promise<this>

  interface: VaultImplementationInterface

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>
  listeners(eventName?: string): Array<Listener>
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this
  removeAllListeners(eventName?: string): this
  off: OnEvent<this>
  on: OnEvent<this>
  once: OnEvent<this>
  removeListener: OnEvent<this>

  functions: {
    COLLATERAL_TOKEN(overrides?: CallOverrides): Promise<[string]>

    EPOCH_LENGTH(overrides?: CallOverrides): Promise<[BigNumber]>

    IMPL_TYPE(overrides?: CallOverrides): Promise<[number]>

    ROUTER(overrides?: CallOverrides): Promise<[string]>

    START(overrides?: CallOverrides): Promise<[BigNumber]>

    STRATEGY_TYPEHASH(overrides?: CallOverrides): Promise<[string]>

    VAULT_FEE(overrides?: CallOverrides): Promise<[BigNumber]>

    asset(overrides?: CallOverrides): Promise<[string]>

    buyoutLien(
      stack: ILienToken.StackStruct[],
      position: PromiseOrValue<BigNumberish>,
      incomingTerms: IAstariaRouter.CommitmentStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>

    commitToLien(
      params: IAstariaRouter.CommitmentStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>

    disableAllowList(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>

    domainSeparator(overrides?: CallOverrides): Promise<[string]>

    enableAllowList(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>

    encodeStrategyData(
      strategy: IAstariaRouter.StrategyDetailsParamStruct,
      root: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[string]>

    getShutdown(overrides?: CallOverrides): Promise<[boolean]>

    getStrategistNonce(overrides?: CallOverrides): Promise<[BigNumber]>

    incrementNonce(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>

    init(
      params: IVaultImplementation.InitParamsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>

    isDelegateOrOwner(
      addr: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>

    modifyAllowList(
      depositor: PromiseOrValue<string>,
      enabled: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>

    modifyDepositCap(
      newCap: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>

    name(overrides?: CallOverrides): Promise<[string]>

    onERC721Received(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<BigNumberish>,
      arg3: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[string]>

    owner(overrides?: CallOverrides): Promise<[string]>

    recipient(overrides?: CallOverrides): Promise<[string]>

    setDelegate(
      delegate_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>

    shutdown(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>

    supportsInterface(
      interfaceId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<[boolean]>

    symbol(overrides?: CallOverrides): Promise<[string]>
  }

  COLLATERAL_TOKEN(overrides?: CallOverrides): Promise<string>

  EPOCH_LENGTH(overrides?: CallOverrides): Promise<BigNumber>

  IMPL_TYPE(overrides?: CallOverrides): Promise<number>

  ROUTER(overrides?: CallOverrides): Promise<string>

  START(overrides?: CallOverrides): Promise<BigNumber>

  STRATEGY_TYPEHASH(overrides?: CallOverrides): Promise<string>

  VAULT_FEE(overrides?: CallOverrides): Promise<BigNumber>

  asset(overrides?: CallOverrides): Promise<string>

  buyoutLien(
    stack: ILienToken.StackStruct[],
    position: PromiseOrValue<BigNumberish>,
    incomingTerms: IAstariaRouter.CommitmentStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>

  commitToLien(
    params: IAstariaRouter.CommitmentStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>

  disableAllowList(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>

  domainSeparator(overrides?: CallOverrides): Promise<string>

  enableAllowList(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>

  encodeStrategyData(
    strategy: IAstariaRouter.StrategyDetailsParamStruct,
    root: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<string>

  getShutdown(overrides?: CallOverrides): Promise<boolean>

  getStrategistNonce(overrides?: CallOverrides): Promise<BigNumber>

  incrementNonce(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>

  init(
    params: IVaultImplementation.InitParamsStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>

  isDelegateOrOwner(
    addr: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>

  modifyAllowList(
    depositor: PromiseOrValue<string>,
    enabled: PromiseOrValue<boolean>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>

  modifyDepositCap(
    newCap: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>

  name(overrides?: CallOverrides): Promise<string>

  onERC721Received(
    arg0: PromiseOrValue<string>,
    arg1: PromiseOrValue<string>,
    arg2: PromiseOrValue<BigNumberish>,
    arg3: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<string>

  owner(overrides?: CallOverrides): Promise<string>

  recipient(overrides?: CallOverrides): Promise<string>

  setDelegate(
    delegate_: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>

  shutdown(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>

  supportsInterface(
    interfaceId: PromiseOrValue<BytesLike>,
    overrides?: CallOverrides
  ): Promise<boolean>

  symbol(overrides?: CallOverrides): Promise<string>

  callStatic: {
    COLLATERAL_TOKEN(overrides?: CallOverrides): Promise<string>

    EPOCH_LENGTH(overrides?: CallOverrides): Promise<BigNumber>

    IMPL_TYPE(overrides?: CallOverrides): Promise<number>

    ROUTER(overrides?: CallOverrides): Promise<string>

    START(overrides?: CallOverrides): Promise<BigNumber>

    STRATEGY_TYPEHASH(overrides?: CallOverrides): Promise<string>

    VAULT_FEE(overrides?: CallOverrides): Promise<BigNumber>

    asset(overrides?: CallOverrides): Promise<string>

    buyoutLien(
      stack: ILienToken.StackStruct[],
      position: PromiseOrValue<BigNumberish>,
      incomingTerms: IAstariaRouter.CommitmentStruct,
      overrides?: CallOverrides
    ): Promise<
      [ILienToken.StackStructOutput[], ILienToken.StackStructOutput] & {
        stacks: ILienToken.StackStructOutput[]
        newStack: ILienToken.StackStructOutput
      }
    >

    commitToLien(
      params: IAstariaRouter.CommitmentStruct,
      overrides?: CallOverrides
    ): Promise<
      [BigNumber, ILienToken.StackStructOutput[]] & {
        lienId: BigNumber
        stack: ILienToken.StackStructOutput[]
      }
    >

    disableAllowList(overrides?: CallOverrides): Promise<void>

    domainSeparator(overrides?: CallOverrides): Promise<string>

    enableAllowList(overrides?: CallOverrides): Promise<void>

    encodeStrategyData(
      strategy: IAstariaRouter.StrategyDetailsParamStruct,
      root: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<string>

    getShutdown(overrides?: CallOverrides): Promise<boolean>

    getStrategistNonce(overrides?: CallOverrides): Promise<BigNumber>

    incrementNonce(overrides?: CallOverrides): Promise<void>

    init(
      params: IVaultImplementation.InitParamsStruct,
      overrides?: CallOverrides
    ): Promise<void>

    isDelegateOrOwner(
      addr: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>

    modifyAllowList(
      depositor: PromiseOrValue<string>,
      enabled: PromiseOrValue<boolean>,
      overrides?: CallOverrides
    ): Promise<void>

    modifyDepositCap(
      newCap: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<void>

    name(overrides?: CallOverrides): Promise<string>

    onERC721Received(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<BigNumberish>,
      arg3: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<string>

    owner(overrides?: CallOverrides): Promise<string>

    recipient(overrides?: CallOverrides): Promise<string>

    setDelegate(
      delegate_: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>

    shutdown(overrides?: CallOverrides): Promise<void>

    supportsInterface(
      interfaceId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<boolean>

    symbol(overrides?: CallOverrides): Promise<string>
  }

  filters: {
    'AllowListEnabled(bool)'(arg0?: null): AllowListEnabledEventFilter
    AllowListEnabled(arg0?: null): AllowListEnabledEventFilter

    'AllowListUpdated(address,bool)'(
      arg0?: null,
      arg1?: null
    ): AllowListUpdatedEventFilter
    AllowListUpdated(arg0?: null, arg1?: null): AllowListUpdatedEventFilter

    'DelegateUpdated(address)'(arg0?: null): DelegateUpdatedEventFilter
    DelegateUpdated(arg0?: null): DelegateUpdatedEventFilter

    'IncrementNonce(uint256)'(nonce?: null): IncrementNonceEventFilter
    IncrementNonce(nonce?: null): IncrementNonceEventFilter

    'NonceUpdated(uint256)'(nonce?: null): NonceUpdatedEventFilter
    NonceUpdated(nonce?: null): NonceUpdatedEventFilter

    'VaultShutdown()'(): VaultShutdownEventFilter
    VaultShutdown(): VaultShutdownEventFilter
  }

  estimateGas: {
    COLLATERAL_TOKEN(overrides?: CallOverrides): Promise<BigNumber>

    EPOCH_LENGTH(overrides?: CallOverrides): Promise<BigNumber>

    IMPL_TYPE(overrides?: CallOverrides): Promise<BigNumber>

    ROUTER(overrides?: CallOverrides): Promise<BigNumber>

    START(overrides?: CallOverrides): Promise<BigNumber>

    STRATEGY_TYPEHASH(overrides?: CallOverrides): Promise<BigNumber>

    VAULT_FEE(overrides?: CallOverrides): Promise<BigNumber>

    asset(overrides?: CallOverrides): Promise<BigNumber>

    buyoutLien(
      stack: ILienToken.StackStruct[],
      position: PromiseOrValue<BigNumberish>,
      incomingTerms: IAstariaRouter.CommitmentStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>

    commitToLien(
      params: IAstariaRouter.CommitmentStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>

    disableAllowList(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>

    domainSeparator(overrides?: CallOverrides): Promise<BigNumber>

    enableAllowList(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>

    encodeStrategyData(
      strategy: IAstariaRouter.StrategyDetailsParamStruct,
      root: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>

    getShutdown(overrides?: CallOverrides): Promise<BigNumber>

    getStrategistNonce(overrides?: CallOverrides): Promise<BigNumber>

    incrementNonce(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>

    init(
      params: IVaultImplementation.InitParamsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>

    isDelegateOrOwner(
      addr: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>

    modifyAllowList(
      depositor: PromiseOrValue<string>,
      enabled: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>

    modifyDepositCap(
      newCap: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>

    name(overrides?: CallOverrides): Promise<BigNumber>

    onERC721Received(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<BigNumberish>,
      arg3: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>

    owner(overrides?: CallOverrides): Promise<BigNumber>

    recipient(overrides?: CallOverrides): Promise<BigNumber>

    setDelegate(
      delegate_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>

    shutdown(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>

    supportsInterface(
      interfaceId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<BigNumber>

    symbol(overrides?: CallOverrides): Promise<BigNumber>
  }

  populateTransaction: {
    COLLATERAL_TOKEN(overrides?: CallOverrides): Promise<PopulatedTransaction>

    EPOCH_LENGTH(overrides?: CallOverrides): Promise<PopulatedTransaction>

    IMPL_TYPE(overrides?: CallOverrides): Promise<PopulatedTransaction>

    ROUTER(overrides?: CallOverrides): Promise<PopulatedTransaction>

    START(overrides?: CallOverrides): Promise<PopulatedTransaction>

    STRATEGY_TYPEHASH(overrides?: CallOverrides): Promise<PopulatedTransaction>

    VAULT_FEE(overrides?: CallOverrides): Promise<PopulatedTransaction>

    asset(overrides?: CallOverrides): Promise<PopulatedTransaction>

    buyoutLien(
      stack: ILienToken.StackStruct[],
      position: PromiseOrValue<BigNumberish>,
      incomingTerms: IAstariaRouter.CommitmentStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>

    commitToLien(
      params: IAstariaRouter.CommitmentStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>

    disableAllowList(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>

    domainSeparator(overrides?: CallOverrides): Promise<PopulatedTransaction>

    enableAllowList(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>

    encodeStrategyData(
      strategy: IAstariaRouter.StrategyDetailsParamStruct,
      root: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>

    getShutdown(overrides?: CallOverrides): Promise<PopulatedTransaction>

    getStrategistNonce(overrides?: CallOverrides): Promise<PopulatedTransaction>

    incrementNonce(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>

    init(
      params: IVaultImplementation.InitParamsStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>

    isDelegateOrOwner(
      addr: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>

    modifyAllowList(
      depositor: PromiseOrValue<string>,
      enabled: PromiseOrValue<boolean>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>

    modifyDepositCap(
      newCap: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>

    name(overrides?: CallOverrides): Promise<PopulatedTransaction>

    onERC721Received(
      arg0: PromiseOrValue<string>,
      arg1: PromiseOrValue<string>,
      arg2: PromiseOrValue<BigNumberish>,
      arg3: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>

    recipient(overrides?: CallOverrides): Promise<PopulatedTransaction>

    setDelegate(
      delegate_: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>

    shutdown(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>

    supportsInterface(
      interfaceId: PromiseOrValue<BytesLike>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>

    symbol(overrides?: CallOverrides): Promise<PopulatedTransaction>
  }
}
