/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from 'ethers'
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from '@ethersproject/abi'
import type { Listener, Provider } from '@ethersproject/providers'
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
  PromiseOrValue,
} from './common'

export type OfferItemStruct = {
  itemType: PromiseOrValue<BigNumberish>
  token: PromiseOrValue<string>
  identifierOrCriteria: PromiseOrValue<BigNumberish>
  startAmount: PromiseOrValue<BigNumberish>
  endAmount: PromiseOrValue<BigNumberish>
}

export type OfferItemStructOutput = [
  number,
  string,
  BigNumber,
  BigNumber,
  BigNumber
] & {
  itemType: number
  token: string
  identifierOrCriteria: BigNumber
  startAmount: BigNumber
  endAmount: BigNumber
}

export type ConsiderationItemStruct = {
  itemType: PromiseOrValue<BigNumberish>
  token: PromiseOrValue<string>
  identifierOrCriteria: PromiseOrValue<BigNumberish>
  startAmount: PromiseOrValue<BigNumberish>
  endAmount: PromiseOrValue<BigNumberish>
  recipient: PromiseOrValue<string>
}

export type ConsiderationItemStructOutput = [
  number,
  string,
  BigNumber,
  BigNumber,
  BigNumber,
  string
] & {
  itemType: number
  token: string
  identifierOrCriteria: BigNumber
  startAmount: BigNumber
  endAmount: BigNumber
  recipient: string
}

export type OrderParametersStruct = {
  offerer: PromiseOrValue<string>
  zone: PromiseOrValue<string>
  offer: OfferItemStruct[]
  consideration: ConsiderationItemStruct[]
  orderType: PromiseOrValue<BigNumberish>
  startTime: PromiseOrValue<BigNumberish>
  endTime: PromiseOrValue<BigNumberish>
  zoneHash: PromiseOrValue<BytesLike>
  salt: PromiseOrValue<BigNumberish>
  conduitKey: PromiseOrValue<BytesLike>
  totalOriginalConsiderationItems: PromiseOrValue<BigNumberish>
}

export type OrderParametersStructOutput = [
  string,
  string,
  OfferItemStructOutput[],
  ConsiderationItemStructOutput[],
  number,
  BigNumber,
  BigNumber,
  string,
  BigNumber,
  string,
  BigNumber
] & {
  offerer: string
  zone: string
  offer: OfferItemStructOutput[]
  consideration: ConsiderationItemStructOutput[]
  orderType: number
  startTime: BigNumber
  endTime: BigNumber
  zoneHash: string
  salt: BigNumber
  conduitKey: string
  totalOriginalConsiderationItems: BigNumber
}

export declare namespace ILienToken {
  export type DetailsStruct = {
    maxAmount: PromiseOrValue<BigNumberish>
    rate: PromiseOrValue<BigNumberish>
    duration: PromiseOrValue<BigNumberish>
    maxPotentialDebt: PromiseOrValue<BigNumberish>
    liquidationInitialAsk: PromiseOrValue<BigNumberish>
  }

  export type DetailsStructOutput = [
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber,
    BigNumber
  ] & {
    maxAmount: BigNumber
    rate: BigNumber
    duration: BigNumber
    maxPotentialDebt: BigNumber
    liquidationInitialAsk: BigNumber
  }

  export type LienStruct = {
    collateralType: PromiseOrValue<BigNumberish>
    token: PromiseOrValue<string>
    vault: PromiseOrValue<string>
    strategyRoot: PromiseOrValue<BytesLike>
    collateralId: PromiseOrValue<BigNumberish>
    details: ILienToken.DetailsStruct
  }

  export type LienStructOutput = [
    number,
    string,
    string,
    string,
    BigNumber,
    ILienToken.DetailsStructOutput
  ] & {
    collateralType: number
    token: string
    vault: string
    strategyRoot: string
    collateralId: BigNumber
    details: ILienToken.DetailsStructOutput
  }

  export type PointStruct = {
    amount: PromiseOrValue<BigNumberish>
    last: PromiseOrValue<BigNumberish>
    end: PromiseOrValue<BigNumberish>
    lienId: PromiseOrValue<BigNumberish>
  }

  export type PointStructOutput = [BigNumber, number, number, BigNumber] & {
    amount: BigNumber
    last: number
    end: number
    lienId: BigNumber
  }

  export type StackStruct = {
    lien: ILienToken.LienStruct
    point: ILienToken.PointStruct
  }

  export type StackStructOutput = [
    ILienToken.LienStructOutput,
    ILienToken.PointStructOutput
  ] & {
    lien: ILienToken.LienStructOutput
    point: ILienToken.PointStructOutput
  }
}

export declare namespace IAstariaRouter {
  export type StrategyDetailsParamStruct = {
    version: PromiseOrValue<BigNumberish>
    deadline: PromiseOrValue<BigNumberish>
    vault: PromiseOrValue<string>
  }

  export type StrategyDetailsParamStructOutput = [number, BigNumber, string] & {
    version: number
    deadline: BigNumber
    vault: string
  }

  export type MerkleDataStruct = {
    root: PromiseOrValue<BytesLike>
    proof: PromiseOrValue<BytesLike>[]
  }

  export type MerkleDataStructOutput = [string, string[]] & {
    root: string
    proof: string[]
  }

  export type NewLienRequestStruct = {
    strategy: IAstariaRouter.StrategyDetailsParamStruct
    stack: ILienToken.StackStruct[]
    nlrDetails: PromiseOrValue<BytesLike>
    merkle: IAstariaRouter.MerkleDataStruct
    amount: PromiseOrValue<BigNumberish>
    v: PromiseOrValue<BigNumberish>
    r: PromiseOrValue<BytesLike>
    s: PromiseOrValue<BytesLike>
  }

  export type NewLienRequestStructOutput = [
    IAstariaRouter.StrategyDetailsParamStructOutput,
    ILienToken.StackStructOutput[],
    string,
    IAstariaRouter.MerkleDataStructOutput,
    BigNumber,
    number,
    string,
    string
  ] & {
    strategy: IAstariaRouter.StrategyDetailsParamStructOutput
    stack: ILienToken.StackStructOutput[]
    nlrDetails: string
    merkle: IAstariaRouter.MerkleDataStructOutput
    amount: BigNumber
    v: number
    r: string
    s: string
  }

  export type CommitmentStruct = {
    tokenContract: PromiseOrValue<string>
    tokenId: PromiseOrValue<BigNumberish>
    lienRequest: IAstariaRouter.NewLienRequestStruct
  }

  export type CommitmentStructOutput = [
    string,
    BigNumber,
    IAstariaRouter.NewLienRequestStructOutput
  ] & {
    tokenContract: string
    tokenId: BigNumber
    lienRequest: IAstariaRouter.NewLienRequestStructOutput
  }

  export type FileStruct = {
    what: PromiseOrValue<BigNumberish>
    data: PromiseOrValue<BytesLike>
  }

  export type FileStructOutput = [number, string] & {
    what: number
    data: string
  }
}

export interface AstariaRouterInterface extends utils.Interface {
  functions: {
    'BEACON_PROXY_IMPLEMENTATION()': FunctionFragment
    'COLLATERAL_TOKEN()': FunctionFragment
    'LIEN_TOKEN()': FunctionFragment
    'TRANSFER_PROXY()': FunctionFragment
    '__acceptGuardian()': FunctionFragment
    '__emergencyPause()': FunctionFragment
    '__emergencyUnpause()': FunctionFragment
    '__renounceGuardian()': FunctionFragment
    'authority()': FunctionFragment
    'canLiquidate(((uint8,address,address,bytes32,uint256,(uint256,uint256,uint256,uint256,uint256)),(uint256,uint40,uint40,uint256)))': FunctionFragment
    'commitToLiens((address,uint256,((uint8,uint256,address),((uint8,address,address,bytes32,uint256,(uint256,uint256,uint256,uint256,uint256)),(uint256,uint40,uint40,uint256))[],bytes,(bytes32,bytes32[]),uint256,uint8,bytes32,bytes32))[])': FunctionFragment
    'deposit(address,address,uint256,uint256)': FunctionFragment
    'depositMax(address,address,uint256)': FunctionFragment
    'depositToVault(address,address,uint256,uint256)': FunctionFragment
    'feeTo()': FunctionFragment
    'file((uint8,bytes))': FunctionFragment
    'fileBatch((uint8,bytes)[])': FunctionFragment
    'fileGuardian((uint8,bytes)[])': FunctionFragment
    'getAuctionWindow()': FunctionFragment
    'getImpl(uint8)': FunctionFragment
    'getLiquidatorFee(uint256)': FunctionFragment
    'getProtocolFee(uint256)': FunctionFragment
    'getStrategyValidator(uint8)': FunctionFragment
    'initialize(address,address,address,address,address,address,address,address,address)': FunctionFragment
    'isValidVault(address)': FunctionFragment
    'liquidate(((uint8,address,address,bytes32,uint256,(uint256,uint256,uint256,uint256,uint256)),(uint256,uint40,uint40,uint256))[],uint8)': FunctionFragment
    'mint(address,address,uint256,uint256)': FunctionFragment
    'multicall(bytes[])': FunctionFragment
    'newPublicVault(uint256,address,address,uint256,bool,address[],uint256)': FunctionFragment
    'newVault(address,address)': FunctionFragment
    'owner()': FunctionFragment
    'paused()': FunctionFragment
    'pullToken(address,uint256,address)': FunctionFragment
    'redeem(address,address,uint256,uint256)': FunctionFragment
    'redeemFutureEpoch(address,uint256,address,uint64)': FunctionFragment
    'redeemMax(address,address,uint256)': FunctionFragment
    'requestLienPosition((address,uint256,((uint8,uint256,address),((uint8,address,address,bytes32,uint256,(uint256,uint256,uint256,uint256,uint256)),(uint256,uint40,uint40,uint256))[],bytes,(bytes32,bytes32[]),uint256,uint8,bytes32,bytes32)),address)': FunctionFragment
    'setAuthority(address)': FunctionFragment
    'setNewGuardian(address)': FunctionFragment
    'transferOwnership(address)': FunctionFragment
    'validateCommitment((address,uint256,((uint8,uint256,address),((uint8,address,address,bytes32,uint256,(uint256,uint256,uint256,uint256,uint256)),(uint256,uint40,uint40,uint256))[],bytes,(bytes32,bytes32[]),uint256,uint8,bytes32,bytes32)),uint256)': FunctionFragment
    'withdraw(address,address,uint256,uint256)': FunctionFragment
  }

  getFunction(
    nameOrSignatureOrTopic:
      | 'BEACON_PROXY_IMPLEMENTATION'
      | 'COLLATERAL_TOKEN'
      | 'LIEN_TOKEN'
      | 'TRANSFER_PROXY'
      | '__acceptGuardian'
      | '__emergencyPause'
      | '__emergencyUnpause'
      | '__renounceGuardian'
      | 'authority'
      | 'canLiquidate'
      | 'commitToLiens'
      | 'deposit'
      | 'depositMax'
      | 'depositToVault'
      | 'feeTo'
      | 'file'
      | 'fileBatch'
      | 'fileGuardian'
      | 'getAuctionWindow'
      | 'getImpl'
      | 'getLiquidatorFee'
      | 'getProtocolFee'
      | 'getStrategyValidator'
      | 'initialize'
      | 'isValidVault'
      | 'liquidate'
      | 'mint'
      | 'multicall'
      | 'newPublicVault'
      | 'newVault'
      | 'owner'
      | 'paused'
      | 'pullToken'
      | 'redeem'
      | 'redeemFutureEpoch'
      | 'redeemMax'
      | 'requestLienPosition'
      | 'setAuthority'
      | 'setNewGuardian'
      | 'transferOwnership'
      | 'validateCommitment'
      | 'withdraw'
  ): FunctionFragment

  encodeFunctionData(
    functionFragment: 'BEACON_PROXY_IMPLEMENTATION',
    values?: undefined
  ): string
  encodeFunctionData(
    functionFragment: 'COLLATERAL_TOKEN',
    values?: undefined
  ): string
  encodeFunctionData(functionFragment: 'LIEN_TOKEN', values?: undefined): string
  encodeFunctionData(
    functionFragment: 'TRANSFER_PROXY',
    values?: undefined
  ): string
  encodeFunctionData(
    functionFragment: '__acceptGuardian',
    values?: undefined
  ): string
  encodeFunctionData(
    functionFragment: '__emergencyPause',
    values?: undefined
  ): string
  encodeFunctionData(
    functionFragment: '__emergencyUnpause',
    values?: undefined
  ): string
  encodeFunctionData(
    functionFragment: '__renounceGuardian',
    values?: undefined
  ): string
  encodeFunctionData(functionFragment: 'authority', values?: undefined): string
  encodeFunctionData(
    functionFragment: 'canLiquidate',
    values: [ILienToken.StackStruct]
  ): string
  encodeFunctionData(
    functionFragment: 'commitToLiens',
    values: [IAstariaRouter.CommitmentStruct[]]
  ): string
  encodeFunctionData(
    functionFragment: 'deposit',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string
  encodeFunctionData(
    functionFragment: 'depositMax',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string
  encodeFunctionData(
    functionFragment: 'depositToVault',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string
  encodeFunctionData(functionFragment: 'feeTo', values?: undefined): string
  encodeFunctionData(
    functionFragment: 'file',
    values: [IAstariaRouter.FileStruct]
  ): string
  encodeFunctionData(
    functionFragment: 'fileBatch',
    values: [IAstariaRouter.FileStruct[]]
  ): string
  encodeFunctionData(
    functionFragment: 'fileGuardian',
    values: [IAstariaRouter.FileStruct[]]
  ): string
  encodeFunctionData(
    functionFragment: 'getAuctionWindow',
    values?: undefined
  ): string
  encodeFunctionData(
    functionFragment: 'getImpl',
    values: [PromiseOrValue<BigNumberish>]
  ): string
  encodeFunctionData(
    functionFragment: 'getLiquidatorFee',
    values: [PromiseOrValue<BigNumberish>]
  ): string
  encodeFunctionData(
    functionFragment: 'getProtocolFee',
    values: [PromiseOrValue<BigNumberish>]
  ): string
  encodeFunctionData(
    functionFragment: 'getStrategyValidator',
    values: [PromiseOrValue<BigNumberish>]
  ): string
  encodeFunctionData(
    functionFragment: 'initialize',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<string>
    ]
  ): string
  encodeFunctionData(
    functionFragment: 'isValidVault',
    values: [PromiseOrValue<string>]
  ): string
  encodeFunctionData(
    functionFragment: 'liquidate',
    values: [ILienToken.StackStruct[], PromiseOrValue<BigNumberish>]
  ): string
  encodeFunctionData(
    functionFragment: 'mint',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string
  encodeFunctionData(
    functionFragment: 'multicall',
    values: [PromiseOrValue<BytesLike>[]]
  ): string
  encodeFunctionData(
    functionFragment: 'newPublicVault',
    values: [
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<boolean>,
      PromiseOrValue<string>[],
      PromiseOrValue<BigNumberish>
    ]
  ): string
  encodeFunctionData(
    functionFragment: 'newVault',
    values: [PromiseOrValue<string>, PromiseOrValue<string>]
  ): string
  encodeFunctionData(functionFragment: 'owner', values?: undefined): string
  encodeFunctionData(functionFragment: 'paused', values?: undefined): string
  encodeFunctionData(
    functionFragment: 'pullToken',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>
    ]
  ): string
  encodeFunctionData(
    functionFragment: 'redeem',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string
  encodeFunctionData(
    functionFragment: 'redeemFutureEpoch',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string
  encodeFunctionData(
    functionFragment: 'redeemMax',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>
    ]
  ): string
  encodeFunctionData(
    functionFragment: 'requestLienPosition',
    values: [IAstariaRouter.CommitmentStruct, PromiseOrValue<string>]
  ): string
  encodeFunctionData(
    functionFragment: 'setAuthority',
    values: [PromiseOrValue<string>]
  ): string
  encodeFunctionData(
    functionFragment: 'setNewGuardian',
    values: [PromiseOrValue<string>]
  ): string
  encodeFunctionData(
    functionFragment: 'transferOwnership',
    values: [PromiseOrValue<string>]
  ): string
  encodeFunctionData(
    functionFragment: 'validateCommitment',
    values: [IAstariaRouter.CommitmentStruct, PromiseOrValue<BigNumberish>]
  ): string
  encodeFunctionData(
    functionFragment: 'withdraw',
    values: [
      PromiseOrValue<string>,
      PromiseOrValue<string>,
      PromiseOrValue<BigNumberish>,
      PromiseOrValue<BigNumberish>
    ]
  ): string

  decodeFunctionResult(
    functionFragment: 'BEACON_PROXY_IMPLEMENTATION',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: 'COLLATERAL_TOKEN',
    data: BytesLike
  ): Result
  decodeFunctionResult(functionFragment: 'LIEN_TOKEN', data: BytesLike): Result
  decodeFunctionResult(
    functionFragment: 'TRANSFER_PROXY',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: '__acceptGuardian',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: '__emergencyPause',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: '__emergencyUnpause',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: '__renounceGuardian',
    data: BytesLike
  ): Result
  decodeFunctionResult(functionFragment: 'authority', data: BytesLike): Result
  decodeFunctionResult(
    functionFragment: 'canLiquidate',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: 'commitToLiens',
    data: BytesLike
  ): Result
  decodeFunctionResult(functionFragment: 'deposit', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'depositMax', data: BytesLike): Result
  decodeFunctionResult(
    functionFragment: 'depositToVault',
    data: BytesLike
  ): Result
  decodeFunctionResult(functionFragment: 'feeTo', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'file', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'fileBatch', data: BytesLike): Result
  decodeFunctionResult(
    functionFragment: 'fileGuardian',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: 'getAuctionWindow',
    data: BytesLike
  ): Result
  decodeFunctionResult(functionFragment: 'getImpl', data: BytesLike): Result
  decodeFunctionResult(
    functionFragment: 'getLiquidatorFee',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: 'getProtocolFee',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: 'getStrategyValidator',
    data: BytesLike
  ): Result
  decodeFunctionResult(functionFragment: 'initialize', data: BytesLike): Result
  decodeFunctionResult(
    functionFragment: 'isValidVault',
    data: BytesLike
  ): Result
  decodeFunctionResult(functionFragment: 'liquidate', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'mint', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'multicall', data: BytesLike): Result
  decodeFunctionResult(
    functionFragment: 'newPublicVault',
    data: BytesLike
  ): Result
  decodeFunctionResult(functionFragment: 'newVault', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'owner', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'paused', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'pullToken', data: BytesLike): Result
  decodeFunctionResult(functionFragment: 'redeem', data: BytesLike): Result
  decodeFunctionResult(
    functionFragment: 'redeemFutureEpoch',
    data: BytesLike
  ): Result
  decodeFunctionResult(functionFragment: 'redeemMax', data: BytesLike): Result
  decodeFunctionResult(
    functionFragment: 'requestLienPosition',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: 'setAuthority',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: 'setNewGuardian',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: 'transferOwnership',
    data: BytesLike
  ): Result
  decodeFunctionResult(
    functionFragment: 'validateCommitment',
    data: BytesLike
  ): Result
  decodeFunctionResult(functionFragment: 'withdraw', data: BytesLike): Result

  events: {
    'AuthorityUpdated(address,address)': EventFragment
    'FileUpdated(uint8,bytes)': EventFragment
    'Initialized(uint8)': EventFragment
    'Liquidation(uint256,uint256)': EventFragment
    'NewVault(address,address,address,uint8)': EventFragment
    'OwnershipTransferred(address,address)': EventFragment
    'Paused(address)': EventFragment
    'Unpaused(address)': EventFragment
  }

  getEvent(nameOrSignatureOrTopic: 'AuthorityUpdated'): EventFragment
  getEvent(nameOrSignatureOrTopic: 'FileUpdated'): EventFragment
  getEvent(nameOrSignatureOrTopic: 'Initialized'): EventFragment
  getEvent(nameOrSignatureOrTopic: 'Liquidation'): EventFragment
  getEvent(nameOrSignatureOrTopic: 'NewVault'): EventFragment
  getEvent(nameOrSignatureOrTopic: 'OwnershipTransferred'): EventFragment
  getEvent(nameOrSignatureOrTopic: 'Paused'): EventFragment
  getEvent(nameOrSignatureOrTopic: 'Unpaused'): EventFragment
}

export interface AuthorityUpdatedEventObject {
  user: string
  newAuthority: string
}
export type AuthorityUpdatedEvent = TypedEvent<
  [string, string],
  AuthorityUpdatedEventObject
>

export type AuthorityUpdatedEventFilter =
  TypedEventFilter<AuthorityUpdatedEvent>

export interface FileUpdatedEventObject {
  what: number
  data: string
}
export type FileUpdatedEvent = TypedEvent<
  [number, string],
  FileUpdatedEventObject
>

export type FileUpdatedEventFilter = TypedEventFilter<FileUpdatedEvent>

export interface InitializedEventObject {
  version: number
}
export type InitializedEvent = TypedEvent<[number], InitializedEventObject>

export type InitializedEventFilter = TypedEventFilter<InitializedEvent>

export interface LiquidationEventObject {
  collateralId: BigNumber
  position: BigNumber
}
export type LiquidationEvent = TypedEvent<
  [BigNumber, BigNumber],
  LiquidationEventObject
>

export type LiquidationEventFilter = TypedEventFilter<LiquidationEvent>

export interface NewVaultEventObject {
  strategist: string
  delegate: string
  vault: string
  vaultType: number
}
export type NewVaultEvent = TypedEvent<
  [string, string, string, number],
  NewVaultEventObject
>

export type NewVaultEventFilter = TypedEventFilter<NewVaultEvent>

export interface OwnershipTransferredEventObject {
  user: string
  newOwner: string
}
export type OwnershipTransferredEvent = TypedEvent<
  [string, string],
  OwnershipTransferredEventObject
>

export type OwnershipTransferredEventFilter =
  TypedEventFilter<OwnershipTransferredEvent>

export interface PausedEventObject {
  account: string
}
export type PausedEvent = TypedEvent<[string], PausedEventObject>

export type PausedEventFilter = TypedEventFilter<PausedEvent>

export interface UnpausedEventObject {
  account: string
}
export type UnpausedEvent = TypedEvent<[string], UnpausedEventObject>

export type UnpausedEventFilter = TypedEventFilter<UnpausedEvent>

export interface AstariaRouter extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this
  attach(addressOrName: string): this
  deployed(): Promise<this>

  interface: AstariaRouterInterface

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>
  listeners(eventName?: string): Array<Listener>
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this
  removeAllListeners(eventName?: string): this
  off: OnEvent<this>
  on: OnEvent<this>
  once: OnEvent<this>
  removeListener: OnEvent<this>

  functions: {
    BEACON_PROXY_IMPLEMENTATION(overrides?: CallOverrides): Promise<[string]>

    COLLATERAL_TOKEN(overrides?: CallOverrides): Promise<[string]>

    LIEN_TOKEN(overrides?: CallOverrides): Promise<[string]>

    TRANSFER_PROXY(overrides?: CallOverrides): Promise<[string]>

    __acceptGuardian(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>

    __emergencyPause(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>

    __emergencyUnpause(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>

    __renounceGuardian(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>

    authority(overrides?: CallOverrides): Promise<[string]>

    canLiquidate(
      stack: ILienToken.StackStruct,
      overrides?: CallOverrides
    ): Promise<[boolean]>

    commitToLiens(
      commitments: IAstariaRouter.CommitmentStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>

    deposit(
      vault: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      minSharesOut: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>

    depositMax(
      vault: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      minSharesOut: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>

    depositToVault(
      vault: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      minSharesOut: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>

    feeTo(overrides?: CallOverrides): Promise<[string]>

    file(
      incoming: IAstariaRouter.FileStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>

    fileBatch(
      files: IAstariaRouter.FileStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>

    fileGuardian(
      file: IAstariaRouter.FileStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>

    getAuctionWindow(overrides?: CallOverrides): Promise<[BigNumber]>

    getImpl(
      implType: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string] & { impl: string }>

    getLiquidatorFee(
      amountIn: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>

    getProtocolFee(
      amountIn: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[BigNumber]>

    getStrategyValidator(
      validator: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<[string]>

    initialize(
      _AUTHORITY: PromiseOrValue<string>,
      _COLLATERAL_TOKEN: PromiseOrValue<string>,
      _LIEN_TOKEN: PromiseOrValue<string>,
      _TRANSFER_PROXY: PromiseOrValue<string>,
      _VAULT_IMPL: PromiseOrValue<string>,
      _SOLO_IMPL: PromiseOrValue<string>,
      _WITHDRAW_IMPL: PromiseOrValue<string>,
      _BEACON_PROXY_IMPL: PromiseOrValue<string>,
      _CLEARING_HOUSE_IMPL: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>

    isValidVault(
      vault: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[boolean]>

    liquidate(
      stack: ILienToken.StackStruct[],
      position: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>

    mint(
      vault: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      shares: PromiseOrValue<BigNumberish>,
      maxAmountIn: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>

    multicall(
      data: PromiseOrValue<BytesLike>[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>

    newPublicVault(
      epochLength: PromiseOrValue<BigNumberish>,
      delegate: PromiseOrValue<string>,
      underlying: PromiseOrValue<string>,
      vaultFee: PromiseOrValue<BigNumberish>,
      allowListEnabled: PromiseOrValue<boolean>,
      allowList: PromiseOrValue<string>[],
      depositCap: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>

    newVault(
      delegate: PromiseOrValue<string>,
      underlying: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>

    owner(overrides?: CallOverrides): Promise<[string]>

    paused(overrides?: CallOverrides): Promise<[boolean]>

    pullToken(
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      recipient: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>

    redeem(
      vault: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      shares: PromiseOrValue<BigNumberish>,
      minAmountOut: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>

    redeemFutureEpoch(
      vault: PromiseOrValue<string>,
      shares: PromiseOrValue<BigNumberish>,
      receiver: PromiseOrValue<string>,
      epoch: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>

    redeemMax(
      vault: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      minAmountOut: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>

    requestLienPosition(
      params: IAstariaRouter.CommitmentStruct,
      receiver: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>

    setAuthority(
      newAuthority: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>

    setNewGuardian(
      _guardian: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>

    validateCommitment(
      commitment: IAstariaRouter.CommitmentStruct,
      timeToSecondEpochEnd: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<
      [ILienToken.LienStructOutput] & { lien: ILienToken.LienStructOutput }
    >

    withdraw(
      vault: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      maxSharesOut: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<ContractTransaction>
  }

  BEACON_PROXY_IMPLEMENTATION(overrides?: CallOverrides): Promise<string>

  COLLATERAL_TOKEN(overrides?: CallOverrides): Promise<string>

  LIEN_TOKEN(overrides?: CallOverrides): Promise<string>

  TRANSFER_PROXY(overrides?: CallOverrides): Promise<string>

  __acceptGuardian(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>

  __emergencyPause(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>

  __emergencyUnpause(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>

  __renounceGuardian(
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>

  authority(overrides?: CallOverrides): Promise<string>

  canLiquidate(
    stack: ILienToken.StackStruct,
    overrides?: CallOverrides
  ): Promise<boolean>

  commitToLiens(
    commitments: IAstariaRouter.CommitmentStruct[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>

  deposit(
    vault: PromiseOrValue<string>,
    to: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    minSharesOut: PromiseOrValue<BigNumberish>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>

  depositMax(
    vault: PromiseOrValue<string>,
    to: PromiseOrValue<string>,
    minSharesOut: PromiseOrValue<BigNumberish>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>

  depositToVault(
    vault: PromiseOrValue<string>,
    to: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    minSharesOut: PromiseOrValue<BigNumberish>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>

  feeTo(overrides?: CallOverrides): Promise<string>

  file(
    incoming: IAstariaRouter.FileStruct,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>

  fileBatch(
    files: IAstariaRouter.FileStruct[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>

  fileGuardian(
    file: IAstariaRouter.FileStruct[],
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>

  getAuctionWindow(overrides?: CallOverrides): Promise<BigNumber>

  getImpl(
    implType: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<string>

  getLiquidatorFee(
    amountIn: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>

  getProtocolFee(
    amountIn: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<BigNumber>

  getStrategyValidator(
    validator: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<string>

  initialize(
    _AUTHORITY: PromiseOrValue<string>,
    _COLLATERAL_TOKEN: PromiseOrValue<string>,
    _LIEN_TOKEN: PromiseOrValue<string>,
    _TRANSFER_PROXY: PromiseOrValue<string>,
    _VAULT_IMPL: PromiseOrValue<string>,
    _SOLO_IMPL: PromiseOrValue<string>,
    _WITHDRAW_IMPL: PromiseOrValue<string>,
    _BEACON_PROXY_IMPL: PromiseOrValue<string>,
    _CLEARING_HOUSE_IMPL: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>

  isValidVault(
    vault: PromiseOrValue<string>,
    overrides?: CallOverrides
  ): Promise<boolean>

  liquidate(
    stack: ILienToken.StackStruct[],
    position: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>

  mint(
    vault: PromiseOrValue<string>,
    to: PromiseOrValue<string>,
    shares: PromiseOrValue<BigNumberish>,
    maxAmountIn: PromiseOrValue<BigNumberish>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>

  multicall(
    data: PromiseOrValue<BytesLike>[],
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>

  newPublicVault(
    epochLength: PromiseOrValue<BigNumberish>,
    delegate: PromiseOrValue<string>,
    underlying: PromiseOrValue<string>,
    vaultFee: PromiseOrValue<BigNumberish>,
    allowListEnabled: PromiseOrValue<boolean>,
    allowList: PromiseOrValue<string>[],
    depositCap: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>

  newVault(
    delegate: PromiseOrValue<string>,
    underlying: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>

  owner(overrides?: CallOverrides): Promise<string>

  paused(overrides?: CallOverrides): Promise<boolean>

  pullToken(
    token: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    recipient: PromiseOrValue<string>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>

  redeem(
    vault: PromiseOrValue<string>,
    to: PromiseOrValue<string>,
    shares: PromiseOrValue<BigNumberish>,
    minAmountOut: PromiseOrValue<BigNumberish>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>

  redeemFutureEpoch(
    vault: PromiseOrValue<string>,
    shares: PromiseOrValue<BigNumberish>,
    receiver: PromiseOrValue<string>,
    epoch: PromiseOrValue<BigNumberish>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>

  redeemMax(
    vault: PromiseOrValue<string>,
    to: PromiseOrValue<string>,
    minAmountOut: PromiseOrValue<BigNumberish>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>

  requestLienPosition(
    params: IAstariaRouter.CommitmentStruct,
    receiver: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>

  setAuthority(
    newAuthority: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>

  setNewGuardian(
    _guardian: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>

  transferOwnership(
    newOwner: PromiseOrValue<string>,
    overrides?: Overrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>

  validateCommitment(
    commitment: IAstariaRouter.CommitmentStruct,
    timeToSecondEpochEnd: PromiseOrValue<BigNumberish>,
    overrides?: CallOverrides
  ): Promise<ILienToken.LienStructOutput>

  withdraw(
    vault: PromiseOrValue<string>,
    to: PromiseOrValue<string>,
    amount: PromiseOrValue<BigNumberish>,
    maxSharesOut: PromiseOrValue<BigNumberish>,
    overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
  ): Promise<ContractTransaction>

  callStatic: {
    BEACON_PROXY_IMPLEMENTATION(overrides?: CallOverrides): Promise<string>

    COLLATERAL_TOKEN(overrides?: CallOverrides): Promise<string>

    LIEN_TOKEN(overrides?: CallOverrides): Promise<string>

    TRANSFER_PROXY(overrides?: CallOverrides): Promise<string>

    __acceptGuardian(overrides?: CallOverrides): Promise<void>

    __emergencyPause(overrides?: CallOverrides): Promise<void>

    __emergencyUnpause(overrides?: CallOverrides): Promise<void>

    __renounceGuardian(overrides?: CallOverrides): Promise<void>

    authority(overrides?: CallOverrides): Promise<string>

    canLiquidate(
      stack: ILienToken.StackStruct,
      overrides?: CallOverrides
    ): Promise<boolean>

    commitToLiens(
      commitments: IAstariaRouter.CommitmentStruct[],
      overrides?: CallOverrides
    ): Promise<
      [BigNumber[], ILienToken.StackStructOutput[]] & {
        lienIds: BigNumber[]
        stack: ILienToken.StackStructOutput[]
      }
    >

    deposit(
      vault: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      minSharesOut: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>

    depositMax(
      vault: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      minSharesOut: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>

    depositToVault(
      vault: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      minSharesOut: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>

    feeTo(overrides?: CallOverrides): Promise<string>

    file(
      incoming: IAstariaRouter.FileStruct,
      overrides?: CallOverrides
    ): Promise<void>

    fileBatch(
      files: IAstariaRouter.FileStruct[],
      overrides?: CallOverrides
    ): Promise<void>

    fileGuardian(
      file: IAstariaRouter.FileStruct[],
      overrides?: CallOverrides
    ): Promise<void>

    getAuctionWindow(overrides?: CallOverrides): Promise<BigNumber>

    getImpl(
      implType: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>

    getLiquidatorFee(
      amountIn: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>

    getProtocolFee(
      amountIn: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>

    getStrategyValidator(
      validator: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>

    initialize(
      _AUTHORITY: PromiseOrValue<string>,
      _COLLATERAL_TOKEN: PromiseOrValue<string>,
      _LIEN_TOKEN: PromiseOrValue<string>,
      _TRANSFER_PROXY: PromiseOrValue<string>,
      _VAULT_IMPL: PromiseOrValue<string>,
      _SOLO_IMPL: PromiseOrValue<string>,
      _WITHDRAW_IMPL: PromiseOrValue<string>,
      _BEACON_PROXY_IMPL: PromiseOrValue<string>,
      _CLEARING_HOUSE_IMPL: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>

    isValidVault(
      vault: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<boolean>

    liquidate(
      stack: ILienToken.StackStruct[],
      position: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<OrderParametersStructOutput>

    mint(
      vault: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      shares: PromiseOrValue<BigNumberish>,
      maxAmountIn: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>

    multicall(
      data: PromiseOrValue<BytesLike>[],
      overrides?: CallOverrides
    ): Promise<string[]>

    newPublicVault(
      epochLength: PromiseOrValue<BigNumberish>,
      delegate: PromiseOrValue<string>,
      underlying: PromiseOrValue<string>,
      vaultFee: PromiseOrValue<BigNumberish>,
      allowListEnabled: PromiseOrValue<boolean>,
      allowList: PromiseOrValue<string>[],
      depositCap: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<string>

    newVault(
      delegate: PromiseOrValue<string>,
      underlying: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<string>

    owner(overrides?: CallOverrides): Promise<string>

    paused(overrides?: CallOverrides): Promise<boolean>

    pullToken(
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      recipient: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>

    redeem(
      vault: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      shares: PromiseOrValue<BigNumberish>,
      minAmountOut: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>

    redeemFutureEpoch(
      vault: PromiseOrValue<string>,
      shares: PromiseOrValue<BigNumberish>,
      receiver: PromiseOrValue<string>,
      epoch: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>

    redeemMax(
      vault: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      minAmountOut: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>

    requestLienPosition(
      params: IAstariaRouter.CommitmentStruct,
      receiver: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<[BigNumber, ILienToken.StackStructOutput[], BigNumber]>

    setAuthority(
      newAuthority: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>

    setNewGuardian(
      _guardian: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<void>

    validateCommitment(
      commitment: IAstariaRouter.CommitmentStruct,
      timeToSecondEpochEnd: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<ILienToken.LienStructOutput>

    withdraw(
      vault: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      maxSharesOut: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>
  }

  filters: {
    'AuthorityUpdated(address,address)'(
      user?: PromiseOrValue<string> | null,
      newAuthority?: PromiseOrValue<string> | null
    ): AuthorityUpdatedEventFilter
    AuthorityUpdated(
      user?: PromiseOrValue<string> | null,
      newAuthority?: PromiseOrValue<string> | null
    ): AuthorityUpdatedEventFilter

    'FileUpdated(uint8,bytes)'(what?: null, data?: null): FileUpdatedEventFilter
    FileUpdated(what?: null, data?: null): FileUpdatedEventFilter

    'Initialized(uint8)'(version?: null): InitializedEventFilter
    Initialized(version?: null): InitializedEventFilter

    'Liquidation(uint256,uint256)'(
      collateralId?: null,
      position?: null
    ): LiquidationEventFilter
    Liquidation(collateralId?: null, position?: null): LiquidationEventFilter

    'NewVault(address,address,address,uint8)'(
      strategist?: null,
      delegate?: null,
      vault?: null,
      vaultType?: null
    ): NewVaultEventFilter
    NewVault(
      strategist?: null,
      delegate?: null,
      vault?: null,
      vaultType?: null
    ): NewVaultEventFilter

    'OwnershipTransferred(address,address)'(
      user?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null
    ): OwnershipTransferredEventFilter
    OwnershipTransferred(
      user?: PromiseOrValue<string> | null,
      newOwner?: PromiseOrValue<string> | null
    ): OwnershipTransferredEventFilter

    'Paused(address)'(account?: null): PausedEventFilter
    Paused(account?: null): PausedEventFilter

    'Unpaused(address)'(account?: null): UnpausedEventFilter
    Unpaused(account?: null): UnpausedEventFilter
  }

  estimateGas: {
    BEACON_PROXY_IMPLEMENTATION(overrides?: CallOverrides): Promise<BigNumber>

    COLLATERAL_TOKEN(overrides?: CallOverrides): Promise<BigNumber>

    LIEN_TOKEN(overrides?: CallOverrides): Promise<BigNumber>

    TRANSFER_PROXY(overrides?: CallOverrides): Promise<BigNumber>

    __acceptGuardian(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>

    __emergencyPause(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>

    __emergencyUnpause(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>

    __renounceGuardian(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>

    authority(overrides?: CallOverrides): Promise<BigNumber>

    canLiquidate(
      stack: ILienToken.StackStruct,
      overrides?: CallOverrides
    ): Promise<BigNumber>

    commitToLiens(
      commitments: IAstariaRouter.CommitmentStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>

    deposit(
      vault: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      minSharesOut: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>

    depositMax(
      vault: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      minSharesOut: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>

    depositToVault(
      vault: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      minSharesOut: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>

    feeTo(overrides?: CallOverrides): Promise<BigNumber>

    file(
      incoming: IAstariaRouter.FileStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>

    fileBatch(
      files: IAstariaRouter.FileStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>

    fileGuardian(
      file: IAstariaRouter.FileStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>

    getAuctionWindow(overrides?: CallOverrides): Promise<BigNumber>

    getImpl(
      implType: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>

    getLiquidatorFee(
      amountIn: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>

    getProtocolFee(
      amountIn: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>

    getStrategyValidator(
      validator: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>

    initialize(
      _AUTHORITY: PromiseOrValue<string>,
      _COLLATERAL_TOKEN: PromiseOrValue<string>,
      _LIEN_TOKEN: PromiseOrValue<string>,
      _TRANSFER_PROXY: PromiseOrValue<string>,
      _VAULT_IMPL: PromiseOrValue<string>,
      _SOLO_IMPL: PromiseOrValue<string>,
      _WITHDRAW_IMPL: PromiseOrValue<string>,
      _BEACON_PROXY_IMPL: PromiseOrValue<string>,
      _CLEARING_HOUSE_IMPL: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>

    isValidVault(
      vault: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<BigNumber>

    liquidate(
      stack: ILienToken.StackStruct[],
      position: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>

    mint(
      vault: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      shares: PromiseOrValue<BigNumberish>,
      maxAmountIn: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>

    multicall(
      data: PromiseOrValue<BytesLike>[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>

    newPublicVault(
      epochLength: PromiseOrValue<BigNumberish>,
      delegate: PromiseOrValue<string>,
      underlying: PromiseOrValue<string>,
      vaultFee: PromiseOrValue<BigNumberish>,
      allowListEnabled: PromiseOrValue<boolean>,
      allowList: PromiseOrValue<string>[],
      depositCap: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>

    newVault(
      delegate: PromiseOrValue<string>,
      underlying: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>

    owner(overrides?: CallOverrides): Promise<BigNumber>

    paused(overrides?: CallOverrides): Promise<BigNumber>

    pullToken(
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      recipient: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>

    redeem(
      vault: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      shares: PromiseOrValue<BigNumberish>,
      minAmountOut: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>

    redeemFutureEpoch(
      vault: PromiseOrValue<string>,
      shares: PromiseOrValue<BigNumberish>,
      receiver: PromiseOrValue<string>,
      epoch: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>

    redeemMax(
      vault: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      minAmountOut: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>

    requestLienPosition(
      params: IAstariaRouter.CommitmentStruct,
      receiver: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>

    setAuthority(
      newAuthority: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>

    setNewGuardian(
      _guardian: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>

    validateCommitment(
      commitment: IAstariaRouter.CommitmentStruct,
      timeToSecondEpochEnd: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<BigNumber>

    withdraw(
      vault: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      maxSharesOut: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<BigNumber>
  }

  populateTransaction: {
    BEACON_PROXY_IMPLEMENTATION(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>

    COLLATERAL_TOKEN(overrides?: CallOverrides): Promise<PopulatedTransaction>

    LIEN_TOKEN(overrides?: CallOverrides): Promise<PopulatedTransaction>

    TRANSFER_PROXY(overrides?: CallOverrides): Promise<PopulatedTransaction>

    __acceptGuardian(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>

    __emergencyPause(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>

    __emergencyUnpause(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>

    __renounceGuardian(
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>

    authority(overrides?: CallOverrides): Promise<PopulatedTransaction>

    canLiquidate(
      stack: ILienToken.StackStruct,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>

    commitToLiens(
      commitments: IAstariaRouter.CommitmentStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>

    deposit(
      vault: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      minSharesOut: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>

    depositMax(
      vault: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      minSharesOut: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>

    depositToVault(
      vault: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      minSharesOut: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>

    feeTo(overrides?: CallOverrides): Promise<PopulatedTransaction>

    file(
      incoming: IAstariaRouter.FileStruct,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>

    fileBatch(
      files: IAstariaRouter.FileStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>

    fileGuardian(
      file: IAstariaRouter.FileStruct[],
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>

    getAuctionWindow(overrides?: CallOverrides): Promise<PopulatedTransaction>

    getImpl(
      implType: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>

    getLiquidatorFee(
      amountIn: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>

    getProtocolFee(
      amountIn: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>

    getStrategyValidator(
      validator: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>

    initialize(
      _AUTHORITY: PromiseOrValue<string>,
      _COLLATERAL_TOKEN: PromiseOrValue<string>,
      _LIEN_TOKEN: PromiseOrValue<string>,
      _TRANSFER_PROXY: PromiseOrValue<string>,
      _VAULT_IMPL: PromiseOrValue<string>,
      _SOLO_IMPL: PromiseOrValue<string>,
      _WITHDRAW_IMPL: PromiseOrValue<string>,
      _BEACON_PROXY_IMPL: PromiseOrValue<string>,
      _CLEARING_HOUSE_IMPL: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>

    isValidVault(
      vault: PromiseOrValue<string>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>

    liquidate(
      stack: ILienToken.StackStruct[],
      position: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>

    mint(
      vault: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      shares: PromiseOrValue<BigNumberish>,
      maxAmountIn: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>

    multicall(
      data: PromiseOrValue<BytesLike>[],
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>

    newPublicVault(
      epochLength: PromiseOrValue<BigNumberish>,
      delegate: PromiseOrValue<string>,
      underlying: PromiseOrValue<string>,
      vaultFee: PromiseOrValue<BigNumberish>,
      allowListEnabled: PromiseOrValue<boolean>,
      allowList: PromiseOrValue<string>[],
      depositCap: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>

    newVault(
      delegate: PromiseOrValue<string>,
      underlying: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>

    paused(overrides?: CallOverrides): Promise<PopulatedTransaction>

    pullToken(
      token: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      recipient: PromiseOrValue<string>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>

    redeem(
      vault: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      shares: PromiseOrValue<BigNumberish>,
      minAmountOut: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>

    redeemFutureEpoch(
      vault: PromiseOrValue<string>,
      shares: PromiseOrValue<BigNumberish>,
      receiver: PromiseOrValue<string>,
      epoch: PromiseOrValue<BigNumberish>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>

    redeemMax(
      vault: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      minAmountOut: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>

    requestLienPosition(
      params: IAstariaRouter.CommitmentStruct,
      receiver: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>

    setAuthority(
      newAuthority: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>

    setNewGuardian(
      _guardian: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>

    transferOwnership(
      newOwner: PromiseOrValue<string>,
      overrides?: Overrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>

    validateCommitment(
      commitment: IAstariaRouter.CommitmentStruct,
      timeToSecondEpochEnd: PromiseOrValue<BigNumberish>,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>

    withdraw(
      vault: PromiseOrValue<string>,
      to: PromiseOrValue<string>,
      amount: PromiseOrValue<BigNumberish>,
      maxSharesOut: PromiseOrValue<BigNumberish>,
      overrides?: PayableOverrides & { from?: PromiseOrValue<string> }
    ): Promise<PopulatedTransaction>
  }
}
